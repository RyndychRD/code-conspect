### SELECT DISTINCT

`SELECT DISTINCT` - выбор только уникальных значений. Удобно использовать вместе с `COUNT` для получения количества уникальных записей. Можно писать несколько колонок(`DISTINCT col1,col2`), тогда запись будет добавлена только если она уникальна сразу по всем колонкам. При этом получить оставшиеся значения уникальных полей нельзя, так как SQL не знает сколько фактически было вхождений. То есть если есть 3 поля уник1 и 1 поле уник2, то получить остальные колонки по этим полям во всех случаях невозможно

### Сравнение строк через Like и =

По сути при поиске строго соответствия(`LIKE 'str'` и `= 'str'`) разницы в скорости нет. А вот при поиске по шаблону(с использованием %) LIKE всегда сканит всю таблицу, а = - просто ищет соответствие и не может использовать шаблон(строки с `_`,`%`)

### SELECT TOP

Позволяет взять только первые n записей. Синтаксис - `SELECT TOP 10 * FROM videos`. По сути аналогичен LIMIT и не во всех БД поддерживается
Также в некоторых БД(SQL Server/MS Access) можно выбрать первые n процентов записей. Синтаксис - `SELECT TOP 10 PERCENT * FROM videos`

### COUNT
Вообще я про функцию знаю, однако оказывается если вызывать ее с наименованием колонки, то NULL значения посчитаны не будут. То есть `SELECT COUNT(*) FROM videos` выдаст сколько всего видео, а `SELECT COUNT(deleted_at) FROM videos` выдаст сколько удаленных видео

### AS
Тоже функция известная, но встретил момент, что можно использовать наименования с пробелами следующим образом - `SELECT COUNT(*) AS [Many many words with spaces]` или `SELECT COUNT(*) AS "Many many words with spaces"` 
Также ее можно опустить, получив `SELECT COUNT(*) [Many many words with spaces]`. Как по мне хуже читаемо

Также алиасы удобно использовать для конкатенации столбцов. Например, `SELECT CustomerName, Address + ', ' + PostalCode + ' ' + City + ', ' + Country AS Address`. Но для MySQL синтаксис другой - `SELECT CustomerName, CONCAT(Address,', ',PostalCode,', ',City,', ',Country) AS Address`

### SUM
Тоже функция известная, но в ней можно использовать математические выражения. Например, `SELECT SUM (price * 10) FROM videos` или `SELECT SUM (price * count) FROM videos`

### AVG
Функция для поиска среднего арифметического. Игнорирует NULL значения

### WILDCARDS
По факту только 2 символа поддерживаются в качестве шаблонов. Есть еще символы, но они справедливы только для некоторых БД, с которыми я не работал. И все они используются с `LIKE`. Но в некоторых СУБД поддерживается оператор REGEXP, который уже представляет собой обычную регулярку

| Symbol | Description                        |
|--------|------------------------------------|
| %      | Represents zero or more characters |
| _      | Represents a single character      |

Также если надо искать сам символ % или _ при использовании оператора LIKE, то его необходимо экранировать. Экранирование в SQL предусмотрено с помощью оператора `ESCAPE`, который указывает, какой конкретно символ будет отвечать за экранирование. Дефолтного символа экранирования нет. Пример: `SELECT file_name FROM files WHERE file_name LIKE '%!%%' ESCAPE '!';`. Здесь символ экранирования - `!`

### REGEXP
SQL поддерживает и обычный синтаксис регулярок. Единственное, модификаторы проставить нельзя и регулярка получается регистронезависимая( REGEXP 'abc' вернет abc и ABC и ABc)

### Сравнение строк
При использовании операторов сравнения (>,<,BETWEEN) для строк строки сравниваются в алфавитном порядке. Просто я как то раньше не думал, что это вообще сработает

### BETWEEN
Оператор известный, но он оказывается всегда во всех системах включает концы в поиск. То есть BETWEEN 1 AND 10 === [1,10]

### SELF JOIN
JOIN таблицы самой к себе. Синтаксис - `SELECT column_name(s) FROM table1 T1, table1 T2 WHERE condition;`. Вообще тут меня несколько ввели в заблуждение, это по сути обычный INNER JOIN и может быть расписан как `SELECT column_name(s) FROM table1 T1 JOIN table1 T2 ON T1.id=T2.id WHERE condition;`. И в такой записи появляется гораздо больше логики.
Применяется обычно для построения иерархии(кто кому начальник, кто кого завел, etc)

### UNION, INTERSECT, EXCEPT

`UNION` - оператор объединения запросов. Служит когда надо объединить результаты запросов из разных таблиц, которые между собой не связаны, но похожи структурой. Например, есть таблица users и таблица customers, нам надо получить все имена из этих двух таблиц. Тогда запрос будет таким `SELECT name FROM users UNION SELECT name FROM customers`.

По умолчанию `UNION` удаляет повторяющиеся значения. Если надо их сохранить - используй `UNION ALL`

При использовании UNION необходимо, чтобы выбираемые колонки совпадали по порядку и типу. То есть такой запрос работать не будет `SELECT name, age FROM users UNION SELECT age,name FROM customers`

Также есть INTERSECT - по логике и синтаксису такой же как UNION, но возвращает записи только первого SELECT, которые имеют совпадения во втором элементе SELECT.
И есть EXCEPT - по логике и синтаксису такой же как UNION, но возвращает записи только первого SELECT, которые не имеют совпадения(полного) во втором элементе SELECT.

### GROUP BY

Группирует записи по некоторому признаку. Зачастую используется с агрегированными функциями(COUNT, MAX, MIN...). 
Для этого оператора NULL является реальным значением. То есть если группировать по полям с NULL, то записи с NULL попадут в отдельную категорию

Синтаксис - `SELECT COUNT(id) FROM videos GROUP BY type`

Можно группировать по нескольким столбцам для более мелкого разбиения

При использовании GROUP BY можно выводить в SELECT только следующие значения:

1. Литералы - то есть константные значения. Например, `SELECT home_type, "literal" FROM Rooms GROUP BY home_type`
2. Результаты агрегатных функций. Например, `SELECT COUNT(id) FROM videos GROUP BY type`
3. Поля, по которым была произведена группировка, так как в рамках одной группы поля, по которым осуществлялась группировка, одинаковые.

### HAVING

Это по сути WHERE для групп из GROUP BY. С помощью HAVING можно фильтровать полученные группы, а также использовать агрегатные функции для этих фильтраций. 

Например, выведем только те группы, средняя стоимость которых больше 50:
```sql
SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
HAVING avg_price > 50
```

### EXIST

Оператор возвращает true если есть хотя бы один результат в запросе, и false в противном случае. Используется зачастую в коррелированных вложенных запросах

Пример:
```sql
SELECT SupplierID, SupplierName
FROM Suppliers
WHERE EXISTS
--  Здесь мы передаем каждую строку из внешнего запроса во внутренний и проверяем, есть ли у нас хотя бы один результат по нему. Если есть - то оставляем строку внешнего запроса, если нет - убираем ее   
    (SELECT * FROM Products WHERE Products.SupplierID = 1 AND Price < 20);
```

### ANY, ALL
Оператор `ANY`:
* возвращает логическое значение в качестве результата
* возвращает TRUE, если ЛЮБОЕ из значений подзапроса удовлетворяет условию

`ANY` означает, что условие будет выполнено, если операция выполняется для любого из значений в диапазоне.

`ANY` можно использовать со стандартными операторами сравнения(=,<,>...). Однако `ANY =` эквивалетнет `IN`, а `IN` читается гораздо логичнее. В общем, использование `ANY =` следует избегать

Однако есть моменты, когда ANY необходим. Например, при использовании оператора > или <. Вот такой запрос с `IN` не перепишешь 
```sql
SELECT * FROM employees
WHERE salary > ANY (SELECT salary FROM employees WHERE department = 'Sales');
```
Здесь мы выбираем таких сотрудников, у которых зарплата больше чем у любого сотрудника из Sales

`ALL` - такой же логический оператор, только возвращает TRUE если ВСЕ значения удовлетворяют условию. То есть такой запрос вернет сотрудников, у которых больше зарплата чем у любого из Sales

Типичный пример использования `ALL` - это проверка какого то условия. Здесь например мы возвращаем буленово значение о том, что у нас нет комнат дороже 200 `SELECT 200 > ALL(SELECT price FROM Rooms)`

```sql
SELECT * FROM employees
WHERE salary > ALL (SELECT salary FROM employees WHERE department = 'Sales');
```

### SELECT INTO

Используется для копирования схемы и данных из одной таблицы в другую. Я так понимаю скорее нужен для миграций, чем для обычных запросов
Синтаксис:
```sql
SELECT * INTO CustomersBackup2017 IN 'Backup.mdb'
FROM Customers; 
```
Также можно использовать только для копирования схемы, если поставить WHERE FALSE

### CASE
Оператор условия. По сути просто if else как он есть. Сложность скорее понять где он нужен и где нет
Синтаксис:
```sql
SELECT OrderID, Quantity,
CASE
    WHEN Quantity > 30 THEN 'The quantity is greater than 30'
    WHEN Quantity = 30 THEN 'The quantity is 30'
    ELSE 'The quantity is under 30'
END AS QuantityText
FROM OrderDetails; 
```

Может также использоваться для ORDER BY или других операторов. Пример:
```sql
SELECT CustomerName, City, Country
FROM Customers
ORDER BY
(CASE
    WHEN City IS NULL THEN Country
    ELSE City
END); 
```

Здесь мы сортируем по City, если он не NULL. Иначе по Country. По факту сначала выйдут записи с City в порядке сортировки, потом записи с Country без City(где City === NULL), потом записи где City и Country ===NULL

Еще `CASE` можно использовать как оператор switch. Синтаксис:
```sql
SELECT name,
CASE SUBSTRING(name, 1, INSTR(name, ' '))
  WHEN 11 THEN "Старшая школа"
  --- Другие значения для Старшой школы
  WHEN 9 THEN "Средняя школа"
  --- Другие значения для Средней школы
  ELSE "Начальная школа"
END AS stage
FROM Class
```

### IF
Кроме `CASE` можно еще использовать `IF`. По своей структуре сильно напоминает ЕСЛИ из Excel. Синтаксис:`SELECT IF(10 > 20, "TRUE", "FALSE");`. По сути просто короткий CASE со всеми вытекающими

### Функции работы с NULL значениями

Иногда может быть задача суммировать значения, часть из которых может быть NULL. В таком случае результат будет NULL, автоматического приведения к 0 не происходит. Для решения такой ситуации есть несколько функций:
1. `IFNULL`(в MySql, в других БД `ISNULL`, `NVL`) - Возвращает второе значение, если первое NULL. Синтаксис `IFNULL(Column,0)` - вернет 0 если Column === NULL
2. `COALESCE`(Я так понял универсальная хрень) - Возвращает первое значение из списка, которое не является NULL. `Синтаксис COALESCE(col1, col2, col3, 'constant')`. Вернет col1, если не NULL. Вернет col2, если col1 NULL и col2 не NULL. И так далее

### WITH
Это команда для создания временной таблицы в рамках запроса. Условно View, но при завершении запроса содержимое таблицы будет удалено

Синтаксис:
```sql
WITH Aeroflot_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot")

SELECT plane, COUNT(plane) AS amount FROM Aeroflot_trips GROUP BY plane;
``` 

Обрати внимание что AS ставится перед самим выражением с SELECT. То есть порядок обратный относительно обычного использования

Также можно в рамках одного WITH создавать несколько временных таблиц. Они разделяются запятой. Пример:
```sql
WITH Aeroflot_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Aeroflot"),  --ЗАПЯТАЯ 
    Don_avia_trips AS
    (SELECT TRIP.* FROM Company
        INNER JOIN Trip ON Trip.company = Company.id WHERE name = "Don_avia")

SELECT * FROM Don_avia_trips UNION SELECT * FROM  Aeroflot_trips;

```

### TRUNCATE
Функция тоже известная, но она имеет ряд важных отличий от `DELETE`. Она не только сбрасывает sequence по PK, она просто удаляет всю таблицу и создает ее заново. При этом НЕ ОТРАБАТЫВАЮТ ТРИГГЕРЫ УДАЛЕНИЯ(об этом я не задумывался). Но из плюсов - работает намного быстрее `DELETE`, так как просто помечает таблицу как удаленную, а не чистит каждую запись отдельно