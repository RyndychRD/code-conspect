### SELECT DISTINCT

`SELECT DISTINCT` - выбор только уникальных значений. Удобно использовать вместе с `COUNT` для получения количества уникальных записей. Можно писать несколько колонок(`DISTINCT col1,col2`), тогда запись будет добавлена только если она уникальна сразу по всем колонкам. При этом получить оставшиеся значения уникальных полей нельзя, так как SQL не знает сколько фактически было вхождений. То есть если есть 3 поля уник1 и 1 поле уник2, то получить остальные колонки по этим полям во всех случаях невозможно

### Сравнение строк через Like и =

По сути при поиске строго соответствия(`LIKE 'str'` и `= 'str'`) разницы в скорости нет. А вот при поиске по шаблону(с использованием %) LIKE всегда сканит всю таблицу, а = - просто ищет соответствие и не может использовать шаблон

### SELECT TOP

Позволяет взять только первые n записей. Синтаксис - `SELECT TOP 10 * FROM videos`. По сути аналогичен LIMIT и не во всех БД поддерживается
Также в некоторых БД(SQL Server/MS Access) можно выбрать первые n процентов записей. Синтаксис - `SELECT TOP 10 PERCENT * FROM videos`

### COUNT
Вообще я про функцию знаю, однако оказывается если вызывать ее с наименованием колонки, то NULL значения посчитаны не будут. То есть `SELECT COUNT(*) FROM videos` выдаст сколько всего видео, а `SELECT COUNT(deleted_at) FROM videos` выдаст сколько удаленных видео

### AS
Тоже функция известная, но встретил момент, что можно использовать наименования с пробелами следующим образом - `SELECT COUNT(*) AS [Many many words with spaces]` или `SELECT COUNT(*) AS "Many many words with spaces"` 
Также ее можно опустить, получив `SELECT COUNT(*) [Many many words with spaces]`. Как по мне хуже читаемо

Также алиасы удобно использовать для конкатенации столбцов. Например, `SELECT CustomerName, Address + ', ' + PostalCode + ' ' + City + ', ' + Country AS Address`. Но для MySQL синтаксис другой - `SELECT CustomerName, CONCAT(Address,', ',PostalCode,', ',City,', ',Country) AS Address`

### SUM
Тоже функция известная, но в ней можно использовать математические выражения. Например, `SELECT SUM (price * 10) FROM videos` или `SELECT SUM (price * count) FROM videos`

### AVG
Функция для поиска среднего арифметического. Игнорирует NULL значения

### WILDCARDS или регулярки
SQL очень плохо поддерживает регулярные выражения. По факту только 2 символа поддерживаются. Есть еще символы, но они справедливы только для некоторых БД, с которыми я не работал. И все они используются с `LIKE`

| Symbol | Description                        |
|--------|------------------------------------|
| %      | Represents zero or more characters |
| _      | Represents a single character      |

### Сравнение строк
При использовании операторов сравнения (>,<,BETWEEN) для строк строки сравниваются в алфавитном порядке. Просто я как то раньше не думал, что это вообще сработает

### BETWEEN
Оператор известный, но он оказывается всегда во всех системах включает концы в поиск. То есть BETWEEN 1 AND 10 === [1,10]

### SELF JOIN
JOIN таблицы самой к себе. Синтаксис - `SELECT column_name(s) FROM table1 T1, table1 T2 WHERE condition;`. Вообще тут меня несколько ввели в заблуждение, это по сути обычный INNER JOIN и может быть расписан как `SELECT column_name(s) FROM table1 T1 JOIN table1 T2 ON T1.id=T2.id WHERE condition;`. И в такой записи появляется гораздо больше логики.
Применяется обычно для построения иерархии(кто кому начальник, кто кого завел, etc)

### UNION, INTERSECT, EXCEPT

`UNION` - оператор объединения запросов. Служит когда надо объединить результаты запросов из разных таблиц, которые между собой не связаны, но похожи структурой. Например, есть таблица users и таблица customers, нам надо получить все имена из этих двух таблиц. Тогда запрос будет таким `SELECT name FROM users UNION SELECT name FROM customers`.

При использовании UNION необходимо, чтобы выбираемые колонки совпадали по порядку и типу. То есть такой запрос работать не будет `SELECT name, age FROM users UNION SELECT age,name FROM customers`

Также есть INTERSECT - по логике и синтаксису такой же как UNION, но возвращает записи только первого SELECT, которые имеют совпадения во втором элементе SELECT.
И есть EXCEPT - по логике и синтаксису такой же как UNION, но возвращает записи только первого SELECT, которые не имеют совпадения(полного) во втором элементе SELECT.

### GROUP BY

Группирует записи по некоторому признаку. Зачастую используется с агрегированными функциями(COUNT, MAX, MIN...). 
Для этого оператора NULL является реальным значением. То есть если группировать по полям с NULL, то записи с NULL попадут в отдельную категорию

Синтаксис - `SELECT COUNT(id) FROM videos GROUP BY type`

Можно группировать по нескольким столбцам для более мелкого разбиения

При использовании GROUP BY можно выводить в SELECT только следующие значения:

1. Литералы - то есть константные значения. Например, `SELECT home_type, "literal" FROM Rooms GROUP BY home_type`
2. Результаты агрегатных функций. Например, `SELECT COUNT(id) FROM videos GROUP BY type`
3. Поля, по которым была произведена группировка, так как в рамках одной группы поля, по которым осуществлялась группировка, одинаковые.

### HAVING

Это по сути WHERE для групп из GROUP BY. С помощью HAVING можно фильтровать полученные группы, а также использовать агрегатные функции для этих фильтраций. 

Например, выведем только те группы, средняя стоимость которых больше 50:
```sql
SELECT home_type, AVG(price) as avg_price FROM Rooms
GROUP BY home_type
HAVING avg_price > 50
```

### EXIST

Оператор возвращает true если есть хотя бы один результат в запросе, и false в противном случае. Используется зачастую в коррелированных вложенных запросах

Пример:
```sql
SELECT SupplierID, SupplierName
FROM Suppliers
WHERE EXISTS
--  Здесь мы передаем каждую строку из внешнего запроса во внутренний и проверяем, есть ли у нас хотя бы один результат по нему. Если есть - то оставляем строку внешнего запроса, если нет - убираем ее   
    (SELECT * FROM Products WHERE Products.SupplierID = 1 AND Price < 20);
```

### ANY, ALL
Оператор `ANY`:
* возвращает логическое значение в качестве результата
* возвращает TRUE, если ЛЮБОЕ из значений подзапроса удовлетворяет условию

`ANY` означает, что условие будет выполнено, если операция выполняется для любого из значений в диапазоне.

`ANY` можно использовать со стандартными операторами сравнения(=,<,>...). Однако `ANY =` эквивалетнет `IN`, а `IN` читается гораздо логичнее. В общем, использование `ANY =` следует избегать

Однако есть моменты, когда ANY необходим. Например, при использовании оператора > или <. Вот такой запрос с `IN` не перепишешь 
```sql
SELECT * FROM employees
WHERE salary > ANY (SELECT salary FROM employees WHERE department = 'Sales');
```
Здесь мы выбираем таких сотрудников, у которых зарплата больше чем у любого сотрудника из Sales

`ALL` - такой же логический оператор, только возвращает TRUE если ВСЕ значения удовлетворяют условию. То есть такой запрос вернет сотрудников, у которых больше зарплата чем у любого из Sales

```sql
SELECT * FROM employees
WHERE salary > ALL (SELECT salary FROM employees WHERE department = 'Sales');
```

### SELECT INTO

Используется для копирования схемы и данных из одной таблицы в другую. Я так понимаю скорее нужен для миграций, чем для обычных запросов
Синтаксис:
```sql
SELECT * INTO CustomersBackup2017 IN 'Backup.mdb'
FROM Customers; 
```
Также можно использовать только для копирования схемы, если поставить WHERE FALSE

### CASE
Оператор условия. По сути просто if else как он есть. Сложность скорее понять где он нужен и где нет
Синтаксис:
```sql
SELECT OrderID, Quantity,
CASE
    WHEN Quantity > 30 THEN 'The quantity is greater than 30'
    WHEN Quantity = 30 THEN 'The quantity is 30'
    ELSE 'The quantity is under 30'
END AS QuantityText
FROM OrderDetails; 
```

Может также использоваться для ORDER BY или других операторов. Пример:
```sql
SELECT CustomerName, City, Country
FROM Customers
ORDER BY
(CASE
    WHEN City IS NULL THEN Country
    ELSE City
END); 
```

Здесь мы сортируем по City, если он не NULL. Иначе по Country. По факту сначала выйдут записи с City в порядке сортировки, потом записи с Country без City(где City === NULL), потом записи где City и Country ===NULL

### Функции работы с NULL значениями

Иногда может быть задача суммировать значения, часть из которых может быть NULL. В таком случае результат будет NULL, автоматического приведения к 0 не происходит. Для решения такой ситуации есть несколько функций:
1. `IFNULL`(в MySql, в других БД `ISNULL`, `NVL`) - Возвращает второе значение, если первое NULL. Синтаксис `IFNULL(Column,0)` - вернет 0 если Column === NULL
2. `COALESCE`(Я так понял универсальная хрень) - Возвращает первое значение из списка, которое не является NULL. `Синтаксис COALESCE(col1, col2, col3, 'constant')`. Вернет col1, если не NULL. Вернет col2, если col1 NULL и col2 не NULL. И так далее
